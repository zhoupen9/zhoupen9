[{"content":" Some network setup requires virtual machine nic works with VLAN. Virtual machines (Linux/Windows/Other) mostly works without vlan tags, and connected port (on switch/virtual switch) in Access mode, which means traffic from/to vm has no vlan tags, and swtich will tag traffic from vm and remove vlan tags to vm (Egress untagged).\nConfiguration For such configuration on Linux bridge, it should be look like: vid 10 pvid 10 egress untagged.\nTo setup such configuration, run\nsudo bridge add vid 10 pvid 10 untagged dev vnetXXX LXD/LXC configuraton LXD/LXC supports to automatically create such a port on Linux bridge, Create a lxc profile contains network configuration will create vethXXXX on parent bridge, and setup connecting port with VLAN.\ndevices: eth0: name: eth0 nictype: bridged parent: br-vpc type: nic vlan: \u0026#34;20\u0026#34; libvirt configuration libvirt does not support setup vlan for virtual nic automatically on none-managed network. To archive vlan configuration automation, create a libvirt hook, /etc/libvirt/hooks/qemu to manipulate network.\nThe hook script reads domain definition XML and transforms with an xsl file, and runs bridge vlan commands to setup VLAN for tap devices, and also runs firewall-cmd command to assign firewalld zone for the tap device, and last records tap device names in a configuration file named by domain name (located in /etc/firewall/libvirt/qemu).\nThe script reads domain definition XML again when virtual machine \u0026#34;stopped\u0026#34;, and run firewall-cmd to remove interface from firewalld zone.\nThe script logs all operation in a log file /var/log/libvirt/hooks.log. /etc/libvirt/hooks/qemu\n#!/usr/bin/bash # /etc/libvirt/hooks/qemu # Docs: https://www.libvirt.org/hooks.html # Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) # Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) # If you save a modified hook script then do \u0026#39;sudo systemctl restart libvirtd\u0026#39;. # This script adds VLAN support to interfaces of libvirt guests on start up. # For more details look at the README file. # Most work is done with the powerful XML transformation of the XML # configuration of the guest on stdin with qemu.xsl to get a normalized # meta information into $META, for example like this # (we need it to understand the script): # # \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; # \u0026lt;meta\u0026gt; # \u0026lt;iface pvid=\u0026#34;26\u0026#34;\u0026gt;vnet1 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;26\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;30\u0026#34;\u0026gt;vnet2 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;0\u0026#34;\u0026gt;vnet3\u0026lt;/iface\u0026gt; # \u0026lt;/meta\u0026gt; # for DEBUG uncomment/comment next three lines #exec 0\u0026lt; start-vdeb11-base02.xml # for DEBUG: read testfile to stdin #BRIDGE=\u0026#34;/usr/bin/echo\u0026#34; BRIDGE=\u0026#34;/usr/sbin/bridge\u0026#34; # and call it with ./qemu \u0026#34;dummy-vm\u0026#34; \u0026#34;start\u0026#34; \u0026#34;begin\u0026#34; \u0026#34;-\u0026#34; XSLFILE=\u0026#34;/etc/libvirt/hooks/qemu.xsl\u0026#34; XMLPROG=\u0026#34;/usr/bin/xmlstarlet\u0026#34; FWCMD=\u0026#34;/usr/bin/firewall-cmd\u0026#34; LOGFILE=\u0026#34;/var/log/libvirt/hooks.log\u0026#34; FWDIR=\u0026#34;/etc/firewall/libvirt/qemu\u0026#34; GUEST=$1 # name of guest being started OPERATION=$2 SUB_OPERATION=$3 EXTRA_PARM=$4 #echo \u0026#39;DEBUG: entering qemu.hook\u0026#39; \u0026gt;\u0026amp;2 case \u0026#34;$OPERATION\u0026#34; in prepare) ;; start) if [[ \u0026#34;$SUB_OPERATION\u0026#34; != \u0026#34;begin\u0026#34; ]] || [[ \u0026#34;$EXTRA_PARM\u0026#34; != \u0026#34;-\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: Unhandled parameter \\$3=\u0026#39;$SUB_OPERATION\u0026#39; or \\$4=\u0026#39;$EXTRA_PARM\u0026#39; to $0 \\$1 \\$2 \\$3 \\$4\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi if [[ ! -x \u0026#34;$XMLPROG\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: $XMLPROG is not executable\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE #cat - \u0026gt;/var/log/libvirt/start-\u0026#34;$1\u0026#34;.xml; exit 1 # get live xml for DEBUG XML=$(cat -) #META=$(\u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34; -) META=$(echo \u0026#34;$XML\u0026#34; | \u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34;) echo \u0026#34;[$GUEST] using hook start with $META\u0026#34; \u0026gt;\u0026gt; $LOGFILE true \u0026gt; $FWDIR/$GUEST # loop through interfaces IFACE_COUNT=0 while true; do ((++IFACE_COUNT)) IFACE=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -c \u0026#34;/meta/iface[$IFACE_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then # finished, no more interfaces available exit 0 fi echo $IFACE \u0026gt;\u0026gt; $FWDIR/$GUEST echo \u0026#34;[$GUEST] turn interface $IFACE flood off\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; link set dev \u0026#34;$IFACE\u0026#34; flood off # add iface to firewalld zone \u0026#39;trusted\u0026#39; echo \u0026#34;[$GUEST] add interface $IFACE to firewall \u0026#39;trusted\u0026#39; zone\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --change-interface $IFACE # configure pvid when meta defined, has default value \u0026#34;0\u0026#34; when not configured # see qmeu.xslt PVID=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/@pvid\u0026#34;) if [[ \u0026#34;$PVID\u0026#34; == \u0026#34;0\u0026#34; ]]; then # delete vid 1 pvid echo \u0026#34;[$GUEST] delete vlan vid 1 pvid 1 dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan delete vid 1 pvid 1 dev \u0026#34;$IFACE\u0026#34; elif [[ \u0026#34;$PVID\u0026#34; == \u0026#34;1\u0026#34; ]]; then echo \u0026#34;[$GUEST] keep vid 1 pvid 1 for $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE else echo \u0026#34;[$GUEST] configure vid pvid $PVID for $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$PVID\u0026#34; dev \u0026#34;$IFACE\u0026#34; pvid \u0026#34;$PVID\u0026#34; untagged fi # loop through vlans on one interface VLAN_COUNT=0 while true; do ((++VLAN_COUNT)) VLAN=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$VLAN\u0026#34; ]]; then # finished, no more vlans available, process next interface break else UNTAGGED=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/@untagged\u0026#34;) if [[ \u0026#34;$UNTAGGED\u0026#34; == \u0026#34;yes\u0026#34; ]]; then echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE pvid $VLAN untagged\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; pvid \u0026#34;$VLAN\u0026#34; untagged else echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; fi fi done ## reload firewalld #$FWCMD --reload done ;; started) ;; stopped) echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE if [[ ! -f \u0026#34;$FWDIR/$GUEST\u0026#34; ]]; then exit 0 fi while IFS= read -r IFACE ; do if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then exit 0 fi echo \u0026#34;[$GUEST] remove $IFACE from firewalld zone \u0026#39;trusted\u0026#39;\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --remove-interface $IFACE done \u0026lt; \u0026#34;$FWDIR/$GUEST\u0026#34; rm -rf \u0026#34;$FWDIR/$GUEST\u0026#34; ;; release) ;; migrate) ;; restore) ;; reconnect) ;; attach) ;; ,*) echo \u0026#34;[$GUEST] Error: qemu hook called with unexpected options $*\u0026#34; \u0026gt;\u0026amp;2 exit 1 ;; esac # vim: set sts=4 sw=4 et autoindent nowrap: This hook script requires an XSL file /etc/libvirt/hooks/qemu.xsl\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- This stylesheet processes the live XML configuration output from a virtual machine managed by libvirt. It transforms the custom metadata information together with attached interfaces and returns a normalized XML with VLAN ids attached to the interface. For further information look at the README file. Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) --\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34; exclude-result-prefixes=\u0026#34;zve\u0026#34;\u0026gt; \u0026lt;xsl:output omit-xml-declaration=\u0026#34;yes\u0026#34; indent=\u0026#34;no\u0026#34; encoding=\u0026#34;utf-8\u0026#34; media-type=\u0026#34;text/xml\u0026#34;/\u0026gt; \u0026lt;xsl:strip-space elements=\u0026#34;*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;text()|@*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/domain\u0026#34;\u0026gt; \u0026lt;meta\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/meta\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#39;*\u0026#39;\u0026gt; \u0026lt;xsl:for-each select=\u0026#39;interface[@type=\u0026#34;bridge\u0026#34;]/target\u0026#39;\u0026gt; \u0026lt;iface\u0026gt; \u0026lt;xsl:variable name=\u0026#34;_index\u0026#34; select=\u0026#34;position()\u0026#34; /\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;pvid\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid != \u0026#39;\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid\u0026#34;/\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;0\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;@dev\u0026#34;/\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/zve:vlan\u0026#34;\u0026gt; \u0026lt;vlan\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;untagged\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;@untagged=\u0026#39;yes\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;yes\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;no\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34;/\u0026gt; \u0026lt;/vlan\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/iface\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;!-- vim: set sts=2 sw=2 et autoindent nowrap: --\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; firewalld We want pfSense in a vm to manage virtual envrionment networks, to achieve that virtual NIC and ports requires to be added to zone trusted.\nsudo firewall-cmd --zone=trusted --change-interface=vnetXXX sudo firewall-cmd --reload For virtual machines and LXD containers, the default vlan id (pvid 1) requires to be removed.\nsudo bridge vlan delete vid 1 pvid dev vnetXXX ","date":"9 March 2023","permalink":"/notes/libvirt-vlan/","section":"Notes","summary":"Some network setup requires virtual machine nic works with VLAN.","title":"Libvirt Vlan"},{"content":" What i\u0026rsquo;ve learnt and what i\u0026rsquo;ve been practcing. ","date":"9 March 2023","permalink":"/notes/","section":"Notes","summary":"What i\u0026rsquo;ve learnt and what i\u0026rsquo;ve been practcing.","title":"Notes"},{"content":" Learning, practice and throughts about software development. ","date":"9 March 2023","permalink":"/","section":"Personal Playground","summary":"Learning, practice and throughts about software development.","title":"Personal Playground"},{"content":" Virtual machines and networking may requires to support VLAN configurations. Proxmox handles configuration much easier than libvirt. see Setup vnet vlan.\nConfiguration in UI In proxmox\u0026#39;s web ui, virtual machine\u0026#39;s network, and lxc container\u0026#39;s network configuration ui has a VLAN Tag option, and it has no VLAN as default.\nSpecifying a valid VLAN tag (2-4094) will cause proxmox setup tap device VLAN id on parent bridge for virtual machines, and setup veth device VLAN id on parent bridge for lxc containers.\nCheck ports and VLAN\nbrctl show bridge vlan show Those VLAN tags configured in web ui proxmox configures as PVID (Port VLAN ID), and also configures as egress untaged. Which means that configured tap device ports and veth device ports on the bridge work like physical switch\u0026#39;s \u0026#34;Access Port\u0026#34;.\nvirtual machines and lxc containers configured this way does not understand and do anything abount VLAN tag. Bridge ports ingress has no VLAN tag, and bridge tags packets using PVID Bridge ports egress remove VLAN if present Bridge switch packets by matching VLAN tags. Configure in conf file Since web ui only support configure PVID based VLAN tags, multiple VLAN tags on a single device (trunk) can not be configured from the web ui. To configure trunk ports, open virtual machines configuration file, and modify network configuration.\nFor example, we want trunk VLAN 10,20,30 to pfSense vm(id 101). Edit /etc/pve/qemu-server/101.conf, and modify network configuration line(s).\nnet0: virtio=01:02:03:04:05:ab,bridge=vmbr0,trunks=10;20;30 NOTE: trunk VLAN tags requires to be separated by \u0026#34;;\u0026#34; (not \u0026#34;,\u0026#34;)\n","date":"9 March 2023","permalink":"/notes/proxmox-vlan/","section":"Notes","summary":"Virtual machines and networking may requires to support VLAN configurations.","title":"Proxmox Vlan"},{"content":" I built my home server last year. The home server uses my old home desktop, Intel i7-4790, Gigabyte z97 and old case. Home server does not require a lot of computing power, but it does requires certain mount of memory.\nServer specification - - CPU intel i7-4790 motherboard Gigabyte z97 memory 4 x 8GB @1600Mhz system disk 1gen m2 256GB SSD NIC onboard intel i217-V Goal NAS I want a network attached storage server to provide samba share, and also to provide iSCSI service for those virtual machines running on my home desktop.\nMedia server I want to run a media server virtual machine (such as jellyfin) store photos and movies.\nSoftware Router I want to run a pfSense server as main router and firewall, and let pfSense to manage all the subnets in my home. I also requires an OpenWrt router to provide proxying service, which allows all the devices to access some non-demostic content.\nPreparation multi-ports NIC To manage my home network, the home server requries a multi-ports network adapter. I bought an used Intel i350T4 server NIC with 4 ports to connect all my home subnet.\n10G NIC To provide higher speed for iSCSI access, i bought two used mallenox ConnectX-3 cards.\nHBA Card I bought an used Broadcom / LSI SAS2308 raid/hba card to connect 3 used small capacity SSDs.\nTopology The home server runs Proxmox VE to host all required virtual machines. Pass PCIe intel i350T4 for pfSesne vm, and one of 4 ports connects to uplink fiber modem. The other 3 ports connect to three subnet of home network.\n| +-------------+ | fiber modem | +-------------+ | +-------------------------------------+ +----------------------+ | pfSense VM | | OpenWrt VM | +-------------------------------------+ +----------------------+ | | | | | | +--------------+ | +---------------------------------------+ | | ASUS Router | | | br-vpc Linux Bridge | | | ap mode | | +---------------------------------------+ | +--------------+ | | | | +----------------------------+ +----------------------+ | | trueNAS Scale VM | | mercury AC/Router | | +----------------------------+ +----------------------+ | 1GB | 10GB | | +---------------------------------------+ +-----------------+ +-------------+ | Home Desktop | |ethernet sockets | | mercury ap | +---------------------------------------+ +-----------------+ +-------------+ pfSense works as a PPPoE dialer, and also connect to my company\u0026#39;s openVPN. pfSense provides DHCP for all my home subnets. pfSense has firewall fules for all subnets Proxmox connect to ASUS Router for management and internet connectivity OpenWrt works as a side router, and connected to a linux bridge trueNAS SCALE server connected to linux bridge as management, and 10GB connected directly to home desktop in a dedicated subnet Mercury configured in one of pfSense managed subnet, and avoid ip address conflicts with pfSense all smart devices connected to ASUS Router (AP) in 2.4Ghz Mercury ap panel only support up to 120Mbps connection Proxmox Proxmox runs serveral lxc containers and virtual machines.\nvm pfSense main router, firewall, PPPoE client, OpenVPN client vm openwrt side router, route traffic to domestic and non-domestic vm trueNAS SCALE NAS server with 3 SSD PCIe pass through, smb, iscsi vm ubunt userver application server container NextCloud runs in trueNAS SCALE k3s cluster lxc gitlab git repository lxc radius dev radius server lxc postgresql database server lxc jellyfin media server (with intel iGPU accel) ","date":"5 March 2023","permalink":"/solution/home-network/","section":"Solution","summary":"I built my home server last year.","title":"Home Network"},{"content":" What i\u0026rsquo;ve been practcing of design and deployment in dev/test/prod environment. ","date":"5 March 2023","permalink":"/solution/","section":"Solution","summary":"What i\u0026rsquo;ve been practcing of design and deployment in dev/test/prod environment.","title":"Solution"},{"content":" I build a new desktop last year (2022-11) as a workstation for my work. The network inside this workstation requires to be able to support:\ncontainerization virtualization traffic routing one router to rule them all I need a single controller to isolate different subnets, allocates ip addresses for subnets, and route traffic to the internet. pfSense is a reliable robust fireall \u0026amp; router.\nroute traffic in one place I need route traffic based on a set of rules so that i can access domestic resource directly, and access non-domestic through a didicated clash endpoint.\nno configuration for any network access end setup clash for every virtual machine, lxc container, desktop, phone or any network access device is tedious, i need a network setup can route traffic in one place and configuration free.\ntopology Workstation uses a pfSense virtual machine as single point to external network (to corp. network and then internet). Virtual machine host system uses a bridge egress to the pfSense VM and then external network.\n| +--------------------+ +------------------+ | pfSense VM | | openwrt vm | +--------------------+ +------------------+ | | | | +----------------+ | +-------------------------+ | br-host | | | br-route | +----------------+ | +-------------------------+ | | | +--------------------------+ | | br-vpc | +-------------+ +--------------------------+ | ap | | | +-------------+ +----------------+ +--------------+ | | lxc containers | | VMs | +-------------+ +----------------+ +--------------+ | phones | +-------------+ external connectivity Block kernel module \u0026#34;igc\u0026#34; for intel I225V ethernet adapter and pass PCIe through to pfSense vm to connect to external network\nwifi (ap) Run hostapd to provide wifi access point for host subnet, and use pfSense as dns server, dhcp server and default gateway.\nsubnets Defines several subnets for host and wifi, lxc container and virtual machiens, and routing openwrt router. Each internal interfaces on pfSense vm configured as subnet gateway and dns server, and pfSense provides DHCP on those internal interfaces.\n172.18.0.0/24 host subnet on \u0026#34;br-host\u0026#34; configured with ip 172.18.0.6/24 172.18.1.0/24 routing subnet on \u0026#34;br-route\u0026#34; 172.18.10.0/24 vpc, 10 VLAN 172.18.20.0/24 vpc, 20 VLAN 172.18.30.0/24 vpc, 30 VLAN traffic routing Add openwrt as a gateway in pfSense, and configure a policy route as firewall rule to route subnet egress traffic (udp and tcp) to openwrt. The policy based route firewall rule will be disabled automatically when pfSense detects openwrt is down, which is a nice touch.\nRun openclash in openwrt router to route traffic based on rules (domestic and non-domestic).\nbr-host pfSense vm has a tap defined and connected to bridge \u0026#34;br-host\u0026#34;, so that host system can route traffic to pfSense. pfSense also provides DHCP on bridge \u0026#34;br-host\u0026#34;, all wifi access will acquire ip address from pfSense and uses pfSense as default gateway.\nbr-route openwrt vm works as a side router, which means pfSense route traffic to openwrt, and openwrt apply rules on egress traffic via a clash tun proxy, and all proxied traffic route back to pfSense (openwrt\u0026#39;s default gatway) and then traffic goes to external network.\ntraffic goes back and forth from pfSense to openwrt may work on any subnet. When openwrt and pfSense interface lay on same subnet with proxied network end, it will encounter connection issue. The egress traffic goes from end to pfSense, pfSense to openwrt, and ingress goes from openwrt directly back to end since they are in same subnet. It will cause host system conntrack considers network traffic as \u0026#34;invalid\u0026#34; state. The default firewalld rules will block ingress traffic. Modifing firewalld default rules can make it work, but it does not make sense.\nSetup a dedicated subnet for routing is a simple way to resolve conntrack state issues.\nbr-vpc A linux bridge named \u0026#34;br-vpc\u0026#34; is set up with VLAN to support lxc containers and virtual machines.\nUpdate Remove \u0026#34;br-route\u0026#34; bridge and add new VLAN \u0026#34;8\u0026#34;. The \u0026#34;br-route\u0026#34; bridge isolates openwrt router and VPC subnets. The isolation prevent host firewalld block invalid conntrack state packget caused by asymentric packet route.\nThe isolation can be archived by isolate subnets in different VLAN as well. I removed the \u0026#34;br-route\u0026#34; bridge and add a new VLAN \u0026#34;8\u0026#34;, and then add this VLAN to pfSense to let pfSense manage the subnet of this VLAN.\nConfigure pfSense vm VLAN and openwrt vm vlan, it works exactly the same as using different bridges.\n","date":"5 March 2023","permalink":"/solution/workstation-network/","section":"Solution","summary":"I build a new desktop last year (2022-11) as a workstation for my work.","title":"Workstation Network"},{"content":" PostgreSQL 12 data files is not compatible with version 14, existing database requires to upgrade.\nIn hosted system In a hosted system, we can install both version 12 and 14, and execute pg_upgrade on the system\nFallback We can always use pg_dump and then psql to import dumped SQL file, dispite losing additional information about existing database.\nIn docker container It\u0026#39;s more complicated when working in docker container environment.\nBackup existing volume or directory Backup existing directory when using bind mount.\nFor example, when bind mount /home/pgdata to postgresql container like -v /home/pgdata:/var/lib/postgresql/data, we can simple cp that directory to a backup.\ncp -a /home/pgdata /home/pgdata_12_backup Backup existing data volume when using volumes.\ndocker run --rm -ti --name backup_volume -v /home/pgdata_12_backup:/pgbackup -v pg_volume:/pgdata ubuntu:22.04 and copy volume content into bind moun directory in the container.\ncp -a /pgdata/* /pgbackup Copy postgresql binary files and shared files Run a PostgreSQL 12 container, and poplulate version 12 binary files and share files into volumes.\ndocker volume create pg12_share docker volume create pg12_bin docker run --rm -ti --name pg12 \\ -e POSTGRES_PASSWORD=s3cr3t \\ -v pg12_share:/usr/share/postgresql/12 \\ -v pg12_bin:/usr/lib/postgresql/12 \\ postgre:12 When PostgreSQL 12 fully started, stop the running container.\ndocker stop pg12 Start a container with postgresql 14 and 12 We can start a PostgreSQL 14 container and then mount 12 files into container to get an environment which has version 12 and version 14.\nPrepare a new volume for upgraded database files.\ndocker volume create pgdata_14 Start a PostgreSQL 14 container with volume mount, and backup bind mount.\nNOTE: mount new data volume for upgraded to other location than postgresql data directory (/var/lib/postgresql/data).\ndocker run --rm -ti --name pg14 \\ -v /home/pgdata_12_backup:/var/lib/postgresql/data12 \\ -v pg12_share:/usr/share/postgresql/12 \\ -v pg12_bin:/usr/lib/postgresql/12 \\ -v pgdata14:/var/lib/postgresql/data14 \\ -e POSTGRES_PASSWORD=secret \\ postgresql:14 Upgrade existing database in postgresql 14 container Enter PostgreSQL 14 container to perform upgrading.\ndocker exec -ti pg14 bash Use --username when existing database\u0026#39;s super user is not postgres. We use sa as an example here.\nchown -R postgres:postgres /var/lib/postgresql/data12 chown -R postgres:postgres /var/lib/postgresql/data14 su postgres cd /var/lib/postgresql # change directory to postgres\u0026#39; home directory /var/lib/postgresql initdb -D $PWD/data14 --username sa pg_upgrade -d $PWD/data12 -D $PWD/data14 --username sa -b /usr/lib/postgresql/12/bin When upgrade finished, we get upgraded database in volume pgdata_14, and then stop running container.\ndocker stop pg14 Mount upgraded database volume and we can volume mount to a new PostgreSQL 14 container as main database files.\ndocker run --rm -ti --name pg14 -v pgdata_14:/var/lib/postgresql/14/data postgres:14 ","date":"3 March 2023","permalink":"/solution/upgrade-pg-from-12-to-14/","section":"Solution","summary":"PostgreSQL 12 data files is not compatible with version 14, existing database requires to upgrade.","title":"Upgrade PostgreSQL From 12 to 14"},{"content":" When we build package/application from source, building process may requires a lot of depending dev packges to be installed, and we don\u0026#39;t really want to install those dev packages, and want ot keeper our system as small, clean as possible.\nExisting solutions:\nbuild source in a fakeroot environment build source in a docker container When building sources only once, or has a low frequency, both solution works perfectly. In some other scenarios, such as frequently build EMACS from source (or any other software), both solution basiclly fetch required packages in every build process, unless environment/containers been kept in host system.\nlxc container In those situation, we can use dedicated lxc containers to build source, and keep those building containers. Docker containers are supposely ephemeral. lxc containers are more like virtual machines and can be kept in system and easily managed.\nSince built package requires to run in host system, the installation process inside lxc container should install packages on host system. To archive that, we need to mount a shared host directory to lxc container in read/write mode.\nAdd configuration in /etc/subgid and /etc/subuid files to allow LXD running as root to remap host\u0026#39;s user ID inside a continer.\necho \u0026#34;root:1000:1\u0026#34; | sudo tee -a /etc/subuid /etc/subgid Map both UID and GID from host to container, and restart container\nlxc config set container_name raw.idmap \u0026#34;both 1000 1000\u0026#34; lxc restart container_name Mount and map directory in host to container in a read/write mode.\nlxc config device add container_name dir_name disk source=/host_path path=/container_path conclusion The lxc container based solution is pretty much the same as docker container, they are all containernization technology after all. If we consider lxc containers as virtual machines, we can\nupdate installed packages along with host system. We can keep docker container and update intalled packages as well, but it doesn\u0026#39;t feels right. upgrade installed system along with host system. Upgrade docker container system looks more weired that update packages. ","date":"16 February 2023","permalink":"/solution/build-source-inside-lxc/","section":"Solution","summary":"When we build package/application from source, building process may requires a lot of depending dev packges to be installed, and we don\u0026#39;t really want to install those dev packages, and want ot keeper our system as small, clean as possible.","title":"Build source inside lxc for host"},{"content":"","date":"16 February 2023","permalink":"/tags/libvirt/","section":"Tags","summary":"","title":"libvirt"},{"content":" Guest virtual machines may requires to know that provisioned disks are ssd or not, so that system runs trim command when discard unused disk spaces.\nenable qemu tags Disk types are not supported by libvirt yet, QEMU command line arguments required when using libvirt.\nAdd qemu:xxx tags mentioned in libvirt QEMU arguments.\nget disk device id for scsi disks, get disk device id line\n\u0026lt;address type=\u0026#34;drive\u0026#34; controller=\u0026#34;0\u0026#34; bus=\u0026#34;0\u0026#34; target=\u0026#34;0\u0026#34; unit=\u0026#34;1\u0026#34;/\u0026gt; the disk device id is scsi0-0-0-1.\nDisk device can be sata or scsi.\nadd qemu override add qemu command line arguments when provide disk \u0026lt;qemu:commandline\u0026gt; \u0026lt;qemu:arg value=\u0026#39;-set\u0026#39;/\u0026gt; \u0026lt;qemu:arg value=\u0026#39;device.scsi0-0-0-1.rotation_rate=1\u0026#39;/\u0026gt; \u0026lt;/qemu:commandline\u0026gt; The qemu command line argument may not work due to \u0026#39;no such device\u0026#39; error. When encountered this error, try override instead.\noverride qemu command line arguments \u0026lt;qemu:override\u0026gt; \u0026lt;qemu:device alias=\u0026#34;scsi0-0-0-1\u0026#34;\u0026gt; \u0026lt;qemu:frontend\u0026gt; \u0026lt;qemu:property name=\u0026#34;rotation_rate\u0026#34; type=\u0026#34;unsigned\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/qemu:frontend\u0026gt; \u0026lt;/qemu:device\u0026gt; \u0026lt;/qemu:override\u0026gt; ","date":"16 February 2023","permalink":"/notes/libvirt-guest-ssd/","section":"Notes","summary":"Guest virtual machines may requires to know that provisioned disks are ssd or not, so that system runs trim command when discard unused disk spaces.","title":"Libvirt Guest SSD"},{"content":"","date":"16 February 2023","permalink":"/tags/ssd/","section":"Tags","summary":"","title":"ssd"},{"content":"Content group by tags.\n","date":"16 February 2023","permalink":"/tags/","section":"Tags","summary":"Content group by tags.","title":"Tags"},{"content":"","date":"16 February 2023","permalink":"/tags/virtualization/","section":"Tags","summary":"","title":"virtualization"},{"content":" Since nftables v0.6 and Linux kernel 4.6, ruleset debug/tracing is supported.\nThis is an equivalent of the old iptables method -J TRACE, but with some great improvements.\nThe steps to enable debug/tracing is the following:\ngive support in your ruleset for it (set nftrace in any of your rules) monitor the trace events from the nft tool Enabling nftrace To enable nftrace in a packet, use a rule with this statement:\nmeta nftrace set 1 After all, nftrace is part of the metainformation of a packet.\nOf course, you may only enable nftrace for a given matching packet. In the example below, we only enable nftrace for tcp packets:\nip protocol tcp meta nftrace set 1 Adjusting nftrace to only your subset of desired packets is key to properly debug the ruleset, otherwise you may get a lot of debug/tracing information which may be overwhelming.\nUse a chain to enable tracing The recommended way to enable tracing is to add a chain for this purpose.\nRegister a trace_chain to enable tracing. If you already have a prerouting chain, then make sure your trace_chain priority comes before your existing prerouting chain.\nnft add chain filter trace_chain { type filter hook prerouting priority -301\\; } nft add rule filter trace_chain meta nftrace set 1 This example assumes you have an existing raw prerouting chain (at priority -300), hence, this is registering a trace chain right before this chain (at priority -301).\nOnce you are done with rule tracing, you can just delete this chain to disable it:\nnft delete chain filter trace_chain monitoring tracing events In nftables, getting the debug/tracing events is a bit different from the iptables world. Now, we have an event-based monitor for the kernel to notify the nft tool.\nThe basic syntax is:\nnft monitor trace Each trace event is assigned an \u0026#39;id\u0026#39; for you to easily follow different packets in the same trace session.\nComplete example Here is complete example of this debug/tracing mechanism in work.\nAssuming you have this ruleset:\ntable ip filter { chain input { type filter hook input priority filter; policy drop; ct state established,related counter packets 2 bytes 292 accept ct state new tcp dport 22 counter packets 0 bytes 0 accept } } Load this ruleset:\nnft -f ruleset.nft Then, add a chain that enables tracing:\nnft add chain ip filter trace_chain { type filter hook prerouting priority -1\\; } This registers the trace_chain before the existing input chain.\nAnd the rule to enable the tracing:\nnft add rule ip filter trace_chain meta nftrace set 1 Simple tracing test, by pinging one host:\nping -c 1 8.8.8.8 You run on a different terminal:\nnft monitor trace # trace id a95ea7ef ip filter trace_chain packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 # trace id a95ea7ef ip filter trace_chain rule meta nftrace set 1 (verdict continue) # trace id a95ea7ef ip filter trace_chain verdict continue # trace id a95ea7ef ip filter trace_chain policy accept # trace id a95ea7ef ip filter input packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 # trace id a95ea7ef ip filter input rule ct state established,related counter packets 168 bytes 53513 accept (verdict accept) The trace id uniquely identifies a packet. The trace describes the packet entering the chain initially.\ntrace id a95ea7ef ip filter trace_chain packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 ","date":"16 February 2023","permalink":"/notes/nft-tracing/","section":"Notes","summary":"Since nftables v0.","title":"Nft Tracing"},{"content":" Docker container based solution is easy to deploy and manage, but Auto IP manage (IPAM) may not be suitable for operations. We can define fixed sub networks for applications/infrastructure.\nDisable docker\u0026#39;s default bridge To disable docker\u0026#39;s default bridge, create /etc/docker/daemon.json with content:\n{ \u0026#34;bridge\u0026#34;: \u0026#34;none\u0026#34; } and restart docker service via sudo systemctl restart docker.service.\nDefine fixed subnet for deployment Define fixed subnet for application with named bridge,\nnetworks: horus: driver: bridge driver_opts: com.docker.network.bridge.name: br-horus com.docker.network.bridge.enable_ip_masquerade: \u0026#39;false\u0026#39; ipam: config: - subnet: \u0026#34;${SUBNET}\u0026#34; Define fixed ingress subnet for ingress.\nnetworks: ingress: driver: bridge driver_opts: com.docker.network.bridge.name: br-ingress com.docker.network.bridge.enable_ip_masquerade: \u0026#39;false\u0026#39; ipam: config: - subnet: \u0026#34;${INGRESS_SUBNET}\u0026#34; Fixed configuration requires to avoid confliction with host network, and can be running on almost all hosts, also operation commands/scripts does not need to modify to adapt host\u0026#39;s network.\nProvide public access Our application containers expose ports on ingress bridge\u0026#39;s ip and port. Internal container within different internal bridge can expose ports on ingress bridge\u0026#39;s ip and port.\nConfigure firewall (iptables/nftables and etc.) to enable DNAT from ingress NIC to ingress bridge\u0026#39;s subnet. We only enable necessary ports and avoid to expose any management ports (such as management ui).\nProvide internal operation access Configure firewall to enable DNAT from operation VPN to ingress bridge\u0026#39;s subnet. We can enable ports of all management ui for operation VPN only.\n","date":"16 February 2023","permalink":"/solution/docker-network/","section":"Solution","summary":"Docker container based solution is easy to deploy and manage, but Auto IP manage (IPAM) may not be suitable for operations.","title":"Configure Docker Network"},{"content":"","date":"16 February 2023","permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker"},{"content":"","date":"16 February 2023","permalink":"/tags/network/","section":"Tags","summary":"","title":"network"},{"content":" To isolate vm instances, we can assign different VLAN to vm instances. libvirt virt-manager does not support VLAN configuration yet, we need a solution to configure VLAN for vm instances.\nSolution Ingo Höft (Ingo@Hoeft-online.de) provides a solution to utilize libvirt hooks to accomplish that task. The idea requires to configure VLAN in vm instance domain definition, and provides a XSL file to transform vm instance domain definition to bare VLAN configuration when vm start/stopped in libvirt hooks, and apply VLAN configurations in those hooks.\n+---------------+ start +-----------------+ +-------------------------------+ +--------------+ | virt-manager | -----------------\u0026gt; | libvirt hooks | ---\u0026gt; | transform domain definition | --\u0026gt; | apply VLAN | +---------------+ stopped +-----------------+ +-------------------------------+ +--------------+ Ingo\u0026#39;s solution apply VLAN for configured vm and it works great. When apply configurations in firewalld in start hook, and then vm stopped, unused interface zone configuration remains in firewalld. We can store vm network configuration in a dedicated configuration file and then remove related firewalld configuration in vm stopped hook.\nDeployment install xmlstarlet To transform vm instance definition, install package\nsudo apt install xmlstarlet libvirt hooks Create file /etc/libvirt/hooks/qemu, and make it executable. chmod +x /etc/libvirt/hooks/qemu. In this hook script, when hook parameter operation is start, run xmlstarlet to transform vm domain definition to get VLAN configurations and apply those configurations via bridge commands. To support firewalld, run firewall-cmd to change vm nic interface to specific zone, i.e. trusted and store vm interface in a configuration file.\nwhen hook parameter operation is stopped, read vm interface from configuration file and run firewall-cmd to remove vm nic interface from specific zone.\n/etc/libvirt/hooks/qemu.xsl\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- This stylesheet processes the live XML configuration output from a virtual machine managed by libvirt. It transforms the custom metadata information together with attached interfaces and returns a normalized XML with VLAN ids attached to the interface. For further information look at the README file. Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) --\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34; exclude-result-prefixes=\u0026#34;zve\u0026#34;\u0026gt; \u0026lt;xsl:output omit-xml-declaration=\u0026#34;yes\u0026#34; indent=\u0026#34;no\u0026#34; encoding=\u0026#34;utf-8\u0026#34; media-type=\u0026#34;text/xml\u0026#34;/\u0026gt; \u0026lt;xsl:strip-space elements=\u0026#34;*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;text()|@*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/domain\u0026#34;\u0026gt; \u0026lt;meta\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/meta\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#39;*\u0026#39;\u0026gt; \u0026lt;xsl:for-each select=\u0026#39;interface[@type=\u0026#34;bridge\u0026#34;]/target\u0026#39;\u0026gt; \u0026lt;iface\u0026gt; \u0026lt;xsl:variable name=\u0026#34;_index\u0026#34; select=\u0026#34;position()\u0026#34; /\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;pvid\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid != \u0026#39;\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid\u0026#34;/\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;0\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;@dev\u0026#34;/\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/zve:vlan\u0026#34;\u0026gt; \u0026lt;vlan\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;untagged\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;@untagged=\u0026#39;yes\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;yes\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;no\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34;/\u0026gt; \u0026lt;/vlan\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/iface\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;!-- vim: set sts=2 sw=2 et autoindent nowrap: --\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; /etc/libvirt/hooks/qemu, in this hook, store vm interface in /etc/firewall/libvirt/qemu/ directory, and each running vm has a dedicated file named as vm\u0026#39;s name in that directory.\n#!/usr/bin/bash # /etc/libvirt/hooks/qemu # Docs: https://www.libvirt.org/hooks.html # Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) # Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) # If you save a modified hook script then do \u0026#39;sudo systemctl restart libvirtd\u0026#39;. # This script adds VLAN support to interfaces of libvirt guests on start up. # For more details look at the README file. # Most work is done with the powerful XML transformation of the XML # configuration of the guest on stdin with qemu.xsl to get a normalized # meta information into $META, for example like this # (we need it to understand the script): # # \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; # \u0026lt;meta\u0026gt; # \u0026lt;iface pvid=\u0026#34;26\u0026#34;\u0026gt;vnet1 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;26\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;30\u0026#34;\u0026gt;vnet2 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;0\u0026#34;\u0026gt;vnet3\u0026lt;/iface\u0026gt; # \u0026lt;/meta\u0026gt; # for DEBUG uncomment/comment next three lines #exec 0\u0026lt; start-vdeb11-base02.xml # for DEBUG: read testfile to stdin #BRIDGE=\u0026#34;/usr/bin/echo\u0026#34; BRIDGE=\u0026#34;/usr/sbin/bridge\u0026#34; # and call it with ./qemu \u0026#34;dummy-vm\u0026#34; \u0026#34;start\u0026#34; \u0026#34;begin\u0026#34; \u0026#34;-\u0026#34; XSLFILE=\u0026#34;/etc/libvirt/hooks/qemu.xsl\u0026#34; XMLPROG=\u0026#34;/usr/bin/xmlstarlet\u0026#34; FWCMD=\u0026#34;/usr/bin/firewall-cmd\u0026#34; LOGFILE=\u0026#34;/var/log/libvirt/hooks.log\u0026#34; FWDIR=\u0026#34;/etc/firewall/libvirt/qemu\u0026#34; GUEST=$1 # name of guest being started OPERATION=$2 SUB_OPERATION=$3 EXTRA_PARM=$4 #echo \u0026#39;DEBUG: entering qemu.hook\u0026#39; \u0026gt;\u0026amp;2 case \u0026#34;$OPERATION\u0026#34; in prepare) ;; start) if [[ \u0026#34;$SUB_OPERATION\u0026#34; != \u0026#34;begin\u0026#34; ]] || [[ \u0026#34;$EXTRA_PARM\u0026#34; != \u0026#34;-\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: Unhandled parameter \\$3=\u0026#39;$SUB_OPERATION\u0026#39; or \\$4=\u0026#39;$EXTRA_PARM\u0026#39; to $0 \\$1 \\$2 \\$3 \\$4\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi if [[ ! -x \u0026#34;$XMLPROG\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: $XMLPROG is not executable\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE #cat - \u0026gt;/var/log/libvirt/start-\u0026#34;$1\u0026#34;.xml; exit 1 # get live xml for DEBUG XML=$(cat -) #META=$(\u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34; -) META=$(echo \u0026#34;$XML\u0026#34; | \u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34;) echo \u0026#34;[$GUEST] using hook start with $META\u0026#34; \u0026gt;\u0026gt; $LOGFILE true \u0026gt; $FWDIR/$GUEST # loop through interfaces IFACE_COUNT=0 while true; do ((++IFACE_COUNT)) IFACE=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -c \u0026#34;/meta/iface[$IFACE_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then # finished, no more interfaces available exit 0 fi echo $IFACE \u0026gt;\u0026gt; $FWDIR/$GUEST echo \u0026#34;[$GUEST] turn interface $IFACE flood off\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; link set dev \u0026#34;$IFACE\u0026#34; flood off # add iface to firewalld zone \u0026#39;trusted\u0026#39; echo \u0026#34;[$GUEST] add interface $IFACE to firewall \u0026#39;trusted\u0026#39; zone\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --change-interface $IFACE # configure pvid when meta defined, has default value \u0026#34;0\u0026#34; when not configured # see qmeu.xslt PVID=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/@pvid\u0026#34;) if [[ \u0026#34;$PVID\u0026#34; == \u0026#34;0\u0026#34; ]]; then # delete vid 1 pvid echo \u0026#34;[$GUEST] delete vlan vid 1 pvid 1 dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan delete vid 1 pvid 1 dev \u0026#34;$IFACE\u0026#34; elif [[ \u0026#34;$PVID\u0026#34; == \u0026#34;1\u0026#34; ]]; then echo \u0026#34;[$GUEST] keep vid 1 pvid 1 for $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE else echo \u0026#34;[$GUEST] configure vid pvid $PVID for $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$PVID\u0026#34; dev \u0026#34;$IFACE\u0026#34; pvid \u0026#34;$PVID\u0026#34; untagged fi # loop through vlans on one interface VLAN_COUNT=0 while true; do ((++VLAN_COUNT)) VLAN=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$VLAN\u0026#34; ]]; then # finished, no more vlans available, process next interface break else UNTAGGED=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/@untagged\u0026#34;) if [[ \u0026#34;$UNTAGGED\u0026#34; == \u0026#34;yes\u0026#34; ]]; then echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE pvid $VLAN untagged\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; pvid \u0026#34;$VLAN\u0026#34; untagged else echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; fi fi done ## reload firewalld #$FWCMD --reload done ;; started) ;; stopped) echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE if [[ ! -f \u0026#34;$FWDIR/$GUEST\u0026#34; ]]; then exit 0 fi while IFS= read -r IFACE ; do if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then exit 0 fi echo \u0026#34;[$GUEST] remove $IFACE from firewalld zone \u0026#39;trusted\u0026#39;\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --remove-interface $IFACE done \u0026lt; \u0026#34;$FWDIR/$GUEST\u0026#34; rm -rf \u0026#34;$FWDIR/$GUEST\u0026#34; ;; release) ;; migrate) ;; restore) ;; reconnect) ;; attach) ;; ,*) echo \u0026#34;[$GUEST] Error: qemu hook called with unexpected options $*\u0026#34; \u0026gt;\u0026amp;2 exit 1 ;; esac # vim: set sts=4 sw=4 et autoindent nowrap: configure vm VLAN For a vm requires untagged single VLAN, add configuration in vm instance definition in domain -\u0026gt; metadata section. Since we defined the xml namespace as zve, xml configuration requirese prefix zve.\n\u0026lt;zve:instance xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34;\u0026gt; \u0026lt;zve:iface\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;30\u0026lt;/zve:vlan\u0026gt; \u0026lt;/zve:iface\u0026gt; \u0026lt;/zve:instance\u0026gt; The configuration defines vm interface has a PVID 30 and egress untagged.\nFor a vm requries multiple VLANs, add configuration\n\u0026lt;zve:instance xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34;\u0026gt; \u0026lt;zve:iface pvid=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;zve:iface\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;10\u0026lt;/zve:vlan\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;20\u0026lt;/zve:vlan\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;30\u0026lt;/zve:vlan\u0026gt; \u0026lt;/zve:iface\u0026gt; \u0026lt;/zve:instance\u0026gt; The configuration defines\nan interface without VLAN (default vid 1, pvid 1) an interface trunk VLAN 10, 20, 30 ","date":"16 February 2023","permalink":"/solution/vm-vlan/","section":"Solution","summary":"To isolate vm instances, we can assign different VLAN to vm instances.","title":"Configure vm VLAN"},{"content":"","date":"16 February 2023","permalink":"/tags/vlan/","section":"Tags","summary":"","title":"vlan"},{"content":"This is the advanced tag. Just like other listing pages in Congo, you can add custom content to individual taxonomy terms and it will be displayed at the top of the term listing. 🚀\nYou can also use these content pages to define Hugo metadata like titles and descriptions that will be used for SEO and other purposes.\n","date":"1 January 0001","permalink":"/tags/advanced/","section":"Tags","summary":"This is the advanced tag.","title":"advanced"},{"content":" Learning, practice and thoughts about coding and design. ","date":"1 January 0001","permalink":"/develop/","section":"Development","summary":"Learning, practice and thoughts about coding and design.","title":"Development"},{"content":" Running multiple docker/lxc containers and few virtual machines on a single workstation requires to design an ioslated multiple VLAN virutalization network.\nDesign The building network requires working in a Desktop vironement, instead of a Server vironment. So the host\u0026#39;s network requires to be managed by NetworkManager.\n+---------------+ | Ethernet NIC | \u0026lt;---------+ +---------------+ | ip routing | +----------------------------------+ | br-gateway (linux bridge) | \u0026lt;----+ +----------------------------------+ | +-----------------+ +--- | router/firewall | +----------------------------------+ | +-----------------+ | br-vpc (linux bridge) | \u0026lt;----+ VLAN trunk +----------------------------------+ VLAN: 20 | | | VLAN: 30 +-----------------+ | +------------------------------+ | lxc container | | | virtual machines (svc/infra) | +-----------------+ | +------------------------------+ +----------------------+ | virtual machines | VLAN: 10 +----------------------+ The br-gateway, br-vpc linux bridge/ovs should be configured via NetworkManager instead of netplan.io, ifup/ifdown scripts.\nAlso configure a Linux bridge with pyhiscal NIC as slave is also not acceptable.\nNetworkManager Create br-gateway linux bridge in nmcli.\nnmcli conn add type bridge ifname br-gateway nmcli conn set connection.id Virtual Environment Gateway nmcli conn set bridge.mac-address 52:54:00:0f:af:0b nmcli conn set ipv4.addresses 172.18.0.1/24 Create br-vpc linux bridge in nmcli.\nnmcli conn add type bridge ifname br-vpc nmcli conn set connection.id Virtual Environment Private nmcli conn set bridge.mac-address 52:54:00:a2:cf:5a nmcli conn set bridge.vlan-filtering 1 nmcli conn set bridge.stp true Host Firewall Remove ubunut firewall, and install firewalld\nsudo apt remove --purge --autoremove ufw sudo apt install firewalld firewall-config firewall-applet We want pfSense as sole firewall for virtual environment, so host firewall does NOT manage networks in virtual environment.\nAdd br-gateway, br-vpc to trusted firewall zone.\nsudo firewall-cmd --permanent --zone trusted --add-interface br-gateway sudo firewall-cmd --permanent --zone trusted --add-interface br-vpc lxc/lxd container Create a new profile named vpc, and and NIC device configuration as:\ndevices: eth0: name: eth0 nictype: bridged parent: br-vpc type: nic vlan: \u0026#34;20\u0026#34; lxc/lxd containers use this profile will assign a bridged veth device eth0, and lay in VLAN 20. Those containers acquire IP address via DHCP managed by pfSense.\nqemu/kvm virtual machines Qemu/kvm virtual machines lay in other VLANs. To support vm VLAN, we can add a libvirt hook to inspect vm instance configuration and assign VLAN to starting vm instance. To do that, vm instance VLAN configuration can be set in vm domain definitions.\nI\u0026#39;ll write annother post about how to configure VLAN for qemu/kvm virtual machines.\n","date":"1 January 0001","permalink":"/solution/virt-network/","section":"Solution","summary":"Running multiple docker/lxc containers and few virtual machines on a single workstation requires to design an ioslated multiple VLAN virutalization network.","title":"Workstation Network Virtualization"}]