[{"content":" Since nftables v0.6 and Linux kernel 4.6, ruleset debug/tracing is supported.\nThis is an equivalent of the old iptables method -J TRACE, but with some great improvements.\nThe steps to enable debug/tracing is the following:\ngive support in your ruleset for it (set nftrace in any of your rules) monitor the trace events from the nft tool Enabling nftrace To enable nftrace in a packet, use a rule with this statement:\nmeta nftrace set 1 After all, nftrace is part of the metainformation of a packet.\nOf course, you may only enable nftrace for a given matching packet. In the example below, we only enable nftrace for tcp packets:\nip protocol tcp meta nftrace set 1 Adjusting nftrace to only your subset of desired packets is key to properly debug the ruleset, otherwise you may get a lot of debug/tracing information which may be overwhelming.\nUse a chain to enable tracing The recommended way to enable tracing is to add a chain for this purpose.\nRegister a trace_chain to enable tracing. If you already have a prerouting chain, then make sure your trace_chain priority comes before your existing prerouting chain.\nnft add chain filter trace_chain { type filter hook prerouting priority -301\\; } nft add rule filter trace_chain meta nftrace set 1 This example assumes you have an existing raw prerouting chain (at priority -300), hence, this is registering a trace chain right before this chain (at priority -301).\nOnce you are done with rule tracing, you can just delete this chain to disable it:\nnft delete chain filter trace_chain monitoring tracing events In nftables, getting the debug/tracing events is a bit different from the iptables world. Now, we have an event-based monitor for the kernel to notify the nft tool.\nThe basic syntax is:\nnft monitor trace Each trace event is assigned an \u0026#39;id\u0026#39; for you to easily follow different packets in the same trace session.\nComplete example Here is complete example of this debug/tracing mechanism in work.\nAssuming you have this ruleset:\ntable ip filter { chain input { type filter hook input priority filter; policy drop; ct state established,related counter packets 2 bytes 292 accept ct state new tcp dport 22 counter packets 0 bytes 0 accept } } Load this ruleset:\nnft -f ruleset.nft Then, add a chain that enables tracing:\nnft add chain ip filter trace_chain { type filter hook prerouting priority -1\\; } This registers the trace_chain before the existing input chain.\nAnd the rule to enable the tracing:\nnft add rule ip filter trace_chain meta nftrace set 1 Simple tracing test, by pinging one host:\nping -c 1 8.8.8.8 You run on a different terminal:\nnft monitor trace # trace id a95ea7ef ip filter trace_chain packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 # trace id a95ea7ef ip filter trace_chain rule meta nftrace set 1 (verdict continue) # trace id a95ea7ef ip filter trace_chain verdict continue # trace id a95ea7ef ip filter trace_chain policy accept # trace id a95ea7ef ip filter input packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 # trace id a95ea7ef ip filter input rule ct state established,related counter packets 168 bytes 53513 accept (verdict accept) The trace id uniquely identifies a packet. The trace describes the packet entering the chain initially.\ntrace id a95ea7ef ip filter trace_chain packet: iif \u0026#34;enp0s25\u0026#34; ether saddr 00:0d:b9:4a:49:3d ether daddr 3c:97:0e:39:aa:20 ip saddr 8.8.8.8 ip daddr 192.168.2.118 ip dscp cs0 ip ecn not-ect ip ttl 115 ip id 0 ip length 84 icmp type echo-reply icmp code net-unreachable icmp id 9253 icmp sequence 1 @th,64,96 24106705117628271805883024640 ","date":"16 February 2023","permalink":"/notes/nft-tracing/","section":"Notes","summary":"Since nftables v0.","title":"Nft Tracing"},{"content":" What i\u0026rsquo;ve learnt and what i\u0026rsquo;ve been practcing. ","date":"16 February 2023","permalink":"/notes/","section":"Notes","summary":"What i\u0026rsquo;ve learnt and what i\u0026rsquo;ve been practcing.","title":"Notes"},{"content":" Learning, practice and throughts about software development. ","date":"16 February 2023","permalink":"/","section":"Personal Playground","summary":"Learning, practice and throughts about software development.","title":"Personal Playground"},{"content":" Docker container based solution is easy to deploy and manage, but Auto IP manage (IPAM) may not be suitable for operations. We can define fixed sub networks for applications/infrastructure.\nDisable docker\u0026#39;s default bridge To disable docker\u0026#39;s default bridge, create /etc/docker/daemon.json with content:\n{ \u0026#34;bridge\u0026#34;: \u0026#34;none\u0026#34; } and restart docker service via sudo systemctl restart docker.service.\nDefine fixed subnet for deployment Define fixed subnet for application with named bridge,\nnetworks: horus: driver: bridge driver_opts: com.docker.network.bridge.name: br-horus com.docker.network.bridge.enable_ip_masquerade: \u0026#39;false\u0026#39; ipam: config: - subnet: \u0026#34;${SUBNET}\u0026#34; Define fixed ingress subnet for ingress.\nnetworks: ingress: driver: bridge driver_opts: com.docker.network.bridge.name: br-ingress com.docker.network.bridge.enable_ip_masquerade: \u0026#39;false\u0026#39; ipam: config: - subnet: \u0026#34;${INGRESS_SUBNET}\u0026#34; Fixed configuration requires to avoid confliction with host network, and can be running on almost all hosts, also operation commands/scripts does not need to modify to adapt host\u0026#39;s network.\nProvide public access Our application containers expose ports on ingress bridge\u0026#39;s ip and port. Internal container within different internal bridge can expose ports on ingress bridge\u0026#39;s ip and port.\nConfigure firewall (iptables/nftables and etc.) to enable DNAT from ingress NIC to ingress bridge\u0026#39;s subnet. We only enable necessary ports and avoid to expose any management ports (such as management ui).\nProvide internal operation access Configure firewall to enable DNAT from operation VPN to ingress bridge\u0026#39;s subnet. We can enable ports of all management ui for operation VPN only.\n","date":"16 February 2023","permalink":"/solution/docker-network/","section":"Solution","summary":"Docker container based solution is easy to deploy and manage, but Auto IP manage (IPAM) may not be suitable for operations.","title":"Configure Docker Network"},{"content":" What i\u0026rsquo;ve been practcing of design and deployment in dev/test/prod environment. ","date":"16 February 2023","permalink":"/solution/","section":"Solution","summary":"What i\u0026rsquo;ve been practcing of design and deployment in dev/test/prod environment.","title":"Solution"},{"content":" To isolate vm instances, we can assign different VLAN to vm instances. libvirt virt-manager does not support VLAN configuration yet, we need a solution to configure VLAN for vm instances.\nSolution Ingo Höft (Ingo@Hoeft-online.de) provides a solution to utilize libvirt hooks to accomplish that task. The idea requires to configure VLAN in vm instance domain definition, and provides a XSL file to transform vm instance domain definition to bare VLAN configuration when vm start/stopped in libvirt hooks, and apply VLAN configurations in those hooks.\n+---------------+ start +-----------------+ +-------------------------------+ +--------------+ | virt-manager | -----------------\u0026gt; | libvirt hooks | ---\u0026gt; | transform domain definition | --\u0026gt; | apply VLAN | +---------------+ stopped +-----------------+ +-------------------------------+ +--------------+ Ingo\u0026#39;s solution apply VLAN for configured vm and it works great. When apply configurations in firewalld in start hook, and then vm stopped, unused interface zone configuration remains in firewalld. We can store vm network configuration in a dedicated configuration file and then remove related firewalld configuration in vm stopped hook.\nDeployment install xmlstarlet To transform vm instance definition, install package\nsudo apt install xmlstarlet libvirt hooks Create file /etc/libvirt/hooks/qemu, and make it executable. chmod +x /etc/libvirt/hooks/qemu. In this hook script, when hook parameter operation is start, run xmlstarlet to transform vm domain definition to get VLAN configurations and apply those configurations via bridge commands. To support firewalld, run firewall-cmd to change vm nic interface to specific zone, i.e. trusted and store vm interface in a configuration file.\nwhen hook parameter operation is stopped, read vm interface from configuration file and run firewall-cmd to remove vm nic interface from specific zone.\n/etc/libvirt/hooks/qemu.xsl\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- This stylesheet processes the live XML configuration output from a virtual machine managed by libvirt. It transforms the custom metadata information together with attached interfaces and returns a normalized XML with VLAN ids attached to the interface. For further information look at the README file. Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) --\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34; exclude-result-prefixes=\u0026#34;zve\u0026#34;\u0026gt; \u0026lt;xsl:output omit-xml-declaration=\u0026#34;yes\u0026#34; indent=\u0026#34;no\u0026#34; encoding=\u0026#34;utf-8\u0026#34; media-type=\u0026#34;text/xml\u0026#34;/\u0026gt; \u0026lt;xsl:strip-space elements=\u0026#34;*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;text()|@*\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/domain\u0026#34;\u0026gt; \u0026lt;meta\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/meta\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#39;*\u0026#39;\u0026gt; \u0026lt;xsl:for-each select=\u0026#39;interface[@type=\u0026#34;bridge\u0026#34;]/target\u0026#39;\u0026gt; \u0026lt;iface\u0026gt; \u0026lt;xsl:variable name=\u0026#34;_index\u0026#34; select=\u0026#34;position()\u0026#34; /\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;pvid\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid != \u0026#39;\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/@pvid\u0026#34;/\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;0\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;@dev\u0026#34;/\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;/*/metadata/zve:instance/zve:iface[$_index]/zve:vlan\u0026#34;\u0026gt; \u0026lt;vlan\u0026gt; \u0026lt;xsl:attribute name=\u0026#34;untagged\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;@untagged=\u0026#39;yes\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;yes\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; \u0026lt;xsl:text\u0026gt;no\u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:attribute\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34;/\u0026gt; \u0026lt;/vlan\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/iface\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;!-- vim: set sts=2 sw=2 et autoindent nowrap: --\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; /etc/libvirt/hooks/qemu, in this hook, store vm interface in /etc/firewall/libvirt/qemu/ directory, and each running vm has a dedicated file named as vm\u0026#39;s name in that directory.\n#!/usr/bin/bash # /etc/libvirt/hooks/qemu # Docs: https://www.libvirt.org/hooks.html # Author: 2021-01-26 - Ingo Höft (Ingo@Hoeft-online.de) # Licence: GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html) # If you save a modified hook script then do \u0026#39;sudo systemctl restart libvirtd\u0026#39;. # This script adds VLAN support to interfaces of libvirt guests on start up. # For more details look at the README file. # Most work is done with the powerful XML transformation of the XML # configuration of the guest on stdin with qemu.xsl to get a normalized # meta information into $META, for example like this # (we need it to understand the script): # # \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; # \u0026lt;meta\u0026gt; # \u0026lt;iface pvid=\u0026#34;26\u0026#34;\u0026gt;vnet1 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;26\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;30\u0026#34;\u0026gt;vnet2 # \u0026lt;vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;30\u0026lt;/vlan\u0026gt; # \u0026lt;vlan untagged=\u0026#34;no\u0026#34;\u0026gt;50\u0026lt;/vlan\u0026gt; # \u0026lt;/iface\u0026gt; # \u0026lt;iface pvid=\u0026#34;0\u0026#34;\u0026gt;vnet3\u0026lt;/iface\u0026gt; # \u0026lt;/meta\u0026gt; # for DEBUG uncomment/comment next three lines #exec 0\u0026lt; start-vdeb11-base02.xml # for DEBUG: read testfile to stdin #BRIDGE=\u0026#34;/usr/bin/echo\u0026#34; BRIDGE=\u0026#34;/usr/sbin/bridge\u0026#34; # and call it with ./qemu \u0026#34;dummy-vm\u0026#34; \u0026#34;start\u0026#34; \u0026#34;begin\u0026#34; \u0026#34;-\u0026#34; XSLFILE=\u0026#34;/etc/libvirt/hooks/qemu.xsl\u0026#34; XMLPROG=\u0026#34;/usr/bin/xmlstarlet\u0026#34; FWCMD=\u0026#34;/usr/bin/firewall-cmd\u0026#34; LOGFILE=\u0026#34;/var/log/libvirt/hooks.log\u0026#34; FWDIR=\u0026#34;/etc/firewall/libvirt/qemu\u0026#34; GUEST=$1 # name of guest being started OPERATION=$2 SUB_OPERATION=$3 EXTRA_PARM=$4 #echo \u0026#39;DEBUG: entering qemu.hook\u0026#39; \u0026gt;\u0026amp;2 case \u0026#34;$OPERATION\u0026#34; in prepare) ;; start) if [[ \u0026#34;$SUB_OPERATION\u0026#34; != \u0026#34;begin\u0026#34; ]] || [[ \u0026#34;$EXTRA_PARM\u0026#34; != \u0026#34;-\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: Unhandled parameter \\$3=\u0026#39;$SUB_OPERATION\u0026#39; or \\$4=\u0026#39;$EXTRA_PARM\u0026#39; to $0 \\$1 \\$2 \\$3 \\$4\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi if [[ ! -x \u0026#34;$XMLPROG\u0026#34; ]]; then echo \u0026#34;[$GUEST] Error: $XMLPROG is not executable\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE #cat - \u0026gt;/var/log/libvirt/start-\u0026#34;$1\u0026#34;.xml; exit 1 # get live xml for DEBUG XML=$(cat -) #META=$(\u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34; -) META=$(echo \u0026#34;$XML\u0026#34; | \u0026#34;$XMLPROG\u0026#34; tr \u0026#34;$XSLFILE\u0026#34;) echo \u0026#34;[$GUEST] using hook start with $META\u0026#34; \u0026gt;\u0026gt; $LOGFILE true \u0026gt; $FWDIR/$GUEST # loop through interfaces IFACE_COUNT=0 while true; do ((++IFACE_COUNT)) IFACE=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -c \u0026#34;/meta/iface[$IFACE_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then # finished, no more interfaces available exit 0 fi echo $IFACE \u0026gt;\u0026gt; $FWDIR/$GUEST echo \u0026#34;[$GUEST] trun interface $IFACE flood off\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; link set dev \u0026#34;$IFACE\u0026#34; flood off # delete vid 1 pvid echo \u0026#34;[$GUEST] delete vlan vid 1 pvid 1 dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan delete vid 1 pvid 1 dev \u0026#34;$IFACE\u0026#34; # add iface to firewalld zone \u0026#39;trusted\u0026#39; echo \u0026#34;[$GUEST] add interface $IFACE to firewall \u0026#39;trusted\u0026#39; zone\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --change-interface $IFACE # loop through vlans on one interface VLAN_COUNT=0 while true; do ((++VLAN_COUNT)) VLAN=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/text()\u0026#34;) if [[ -z \u0026#34;$VLAN\u0026#34; ]]; then # finished, no more vlans available, process next interface break else UNTAGGED=$(echo \u0026#34;$META\u0026#34; | \u0026#34;$XMLPROG\u0026#34; sel -t -v \u0026#34;/meta/iface[$IFACE_COUNT]/vlan[$VLAN_COUNT]/@untagged\u0026#34;) if [[ \u0026#34;$UNTAGGED\u0026#34; == \u0026#34;yes\u0026#34; ]]; then echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE pvid $VLAN untagged\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; pvid \u0026#34;$VLAN\u0026#34; untagged else echo \u0026#34;[$GUEST] add vlan vid $VLAN dev $IFACE\u0026#34; \u0026gt;\u0026gt; $LOGFILE \u0026#34;$BRIDGE\u0026#34; vlan add vid \u0026#34;$VLAN\u0026#34; dev \u0026#34;$IFACE\u0026#34; fi fi done ## reload firewalld #$FWCMD --reload done ;; started) ;; stopped) echo \u0026#34;[$GUEST] hook on $1 $2 $3 $4\u0026#34; \u0026gt;\u0026gt; $LOGFILE if [[ ! -f \u0026#34;$FWDIR/$GUEST\u0026#34; ]]; then exit 0 fi while IFS= read -r IFACE ; do if [[ -z \u0026#34;$IFACE\u0026#34; ]]; then exit 0 fi echo \u0026#34;[$GUEST] remove $IFACE from firewalld zone \u0026#39;trusted\u0026#39;\u0026#34; \u0026gt;\u0026gt; $LOGFILE $FWCMD --zone=trusted --remove-interface $IFACE done \u0026lt; \u0026#34;$FWDIR/$GUEST\u0026#34; rm -rf \u0026#34;$FWDIR/$GUEST\u0026#34; ;; release) ;; migrate) ;; restore) ;; reconnect) ;; attach) ;; ,*) echo \u0026#34;[$GUEST] Error: qemu hook called with unexpected options $*\u0026#34; \u0026gt;\u0026amp;2 exit 1 ;; esac # vim: set sts=4 sw=4 et autoindent nowrap: configure vm VLAN For a vm requires untagged single VLAN, add configuration in vm instance definition in domain -\u0026gt; metadata section. Since we defined the xml namespace as zve, xml configuration requirese prefix zve.\n\u0026lt;zve:instance xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34;\u0026gt; \u0026lt;zve:iface pvid=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;yes\u0026#34;\u0026gt;30\u0026lt;/zve:vlan\u0026gt; \u0026lt;/zve:iface\u0026gt; \u0026lt;/zve:instance\u0026gt; For a vm requries multiple VLANs, add configuration\n\u0026lt;zve:instance xmlns:zve=\u0026#34;http://hoeft-online.de/libvirt\u0026#34;\u0026gt; \u0026lt;zve:iface pvid=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;zve:iface pvid=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;10\u0026lt;/zve:vlan\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;20\u0026lt;/zve:vlan\u0026gt; \u0026lt;zve:vlan untagged=\u0026#34;no\u0026#34;\u0026gt;30\u0026lt;/zve:vlan\u0026gt; \u0026lt;/zve:iface\u0026gt; \u0026lt;/zve:instance\u0026gt; The configuration defines\nan interface without VLAN an interface trunk VLAN 10, 20, 30 ","date":"16 February 2023","permalink":"/solution/vm-vlan/","section":"Solution","summary":"To isolate vm instances, we can assign different VLAN to vm instances.","title":"Configure vm VLAN"},{"content":" Learning, practice and thoughts about coding and design. ","date":"1 January 0001","permalink":"/develop/","section":"Development","summary":"Learning, practice and thoughts about coding and design.","title":"Development"},{"content":"","date":"1 January 0001","permalink":"/tags/network/","section":"Tags","summary":"","title":"network"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" Running multiple docker/lxc containers and few virtual machines on a single workstation requires to design an ioslated multiple VLAN virutalization network.\nDesign The building network requires working in a Desktop vironement, instead of a Server vironment. So the host\u0026#39;s network requires to be managed by NetworkManager.\n+---------------+ | Ethernet NIC | \u0026lt;---------+ +---------------+ | ip routing | +----------------------------------+ | br-gateway (linux bridge) | \u0026lt;----+ +----------------------------------+ | +-----------------+ +--- | router/firewall | +----------------------------------+ | +-----------------+ | br-vpc (linux bridge) | \u0026lt;----+ VLAN trunk +----------------------------------+ VLAN: 20 | | | VLAN: 30 +-----------------+ | +------------------------------+ | lxc container | | | virtual machines (svc/infra) | +-----------------+ | +------------------------------+ +----------------------+ | virtual machines | VLAN: 10 +----------------------+ The br-gateway, br-vpc linux bridge/ovs should be configured via NetworkManager instead of netplan.io, ifup/ifdown scripts.\nAlso configure a Linux bridge with pyhiscal NIC as slave is also not acceptable.\nNetworkManager Create br-gateway linux bridge in nmcli.\nnmcli conn add type bridge ifname br-gateway nmcli conn set connection.id Virtual Environment Gateway nmcli conn set bridge.mac-address 52:54:00:0f:af:0b nmcli conn set ipv4.addresses 172.18.0.1/24 Create br-vpc linux bridge in nmcli.\nnmcli conn add type bridge ifname br-vpc nmcli conn set connection.id Virtual Environment Private nmcli conn set bridge.mac-address 52:54:00:a2:cf:5a nmcli conn set bridge.vlan-filtering 1 nmcli conn set bridge.stp true Host Firewall Remove ubunut firewall, and install firewalld\nsudo apt remove --purge --autoremove ufw sudo apt install firewalld firewall-config firewall-applet We want pfSense as sole firewall for virtual environment, so host firewall does NOT manage networks in virtual environment.\nAdd br-gateway, br-vpc to trusted firewall zone.\nsudo firewall-cmd --permanent --zone trusted --add-interface br-gateway sudo firewall-cmd --permanent --zone trusted --add-interface br-vpc lxc/lxd container Create a new profile named vpc, and and NIC device configuration as:\ndevices: eth0: name: eth0 nictype: bridged parent: br-vpc type: nic vlan: \u0026#34;20\u0026#34; lxc/lxd containers use this profile will assign a bridged veth device eth0, and lay in VLAN 20. Those containers acquire IP address via DHCP managed by pfSense.\nqemu/kvm virtual machines Qemu/kvm virtual machines lay in other VLANs. To support vm VLAN, we can add a libvirt hook to inspect vm instance configuration and assign VLAN to starting vm instance. To do that, vm instance VLAN configuration can be set in vm domain definitions.\nI\u0026#39;ll write annother post about how to configure VLAN for qemu/kvm virtual machines.\n","date":"1 January 0001","permalink":"/solution/virt-network/","section":"Solution","summary":"Running multiple docker/lxc containers and few virtual machines on a single workstation requires to design an ioslated multiple VLAN virutalization network.","title":"Workstation Network Virtualization"}]